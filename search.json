[{"title":"Hello World","url":"/2021/03/06/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"My First Blog","url":"/2021/03/06/My-First-Blog/","content":"大度山\n作者: 余光中\n　你不知道你是谁，你忧郁；你知道你不是谁，你幻灭。\n　\n春天在大度山上喊我竖笛伸长长的颈子喊我（弄蛇人那样地喊我）坐在松松的山坡山晒簇新簇新簇新的太阳耀眼像头条新闻的太阳早餐桌对面坐着的太阳鸭蛋黄，鸭蛋黄，浓浓的太阳春天很新春天在大度山上喊我整条光谱灿烂地喊我红得要恋爱，黄得拍你的眼睛擦亮，长绿锈的旧太阳买一个四月，买一个三月杜鹃花在季节的裙边闹成缤纷的幼稚园春天真吵春天，春天在远方喊我整座相思林的鹧鸪在喊我（蓝色长途车的方向在喊我）三角铃，木琴，巴宋巴宋巴宋宋过了雨季，等着风季问黄泥春天有没有触觉太阳的手指呵瓜田的痒四月最怕痒重重地合起，海盗版的浮士德且关上朝北的窗你曾站在基隆港，不穿雨衣听大邮轮汽笛的震动，肺病的阴云你是望海的少年，不穿雨衣春天在古堡的废垛上绿着白卵石在河床上齿齿笑着清明节，纸钱，黑蝴蝶飞着（连土地公公也要扶杖远游了）情人在公墓里约会贪睡的尸骨也该翻一翻身了一朵月季花踮起了脚尖读谁的碑铭把冬天交给阿司匹灵，啊嚏把你的失眠，你的自卑电线杆电线杆支撑的低空一百万人用过的空气啊嚏啊嚏特效药的广告，细菌，原子雨春天，春天是发呆的季节坐在韩国草上，怔一个下午膝上摊开济慈的诗集春天是不生肺病的春天是延长的愚人节，流行着爱情卓文君死了两千年，春天还是春天还是十七岁，还是十七岁半还是云很天鹅，女学生们很云雀还是云很芭蕾，女学生们很却却春天是不生肺病的合上，存在与不存在主义用你苍白而颤抖的手开抽屉，然后关上的手旋瓶盖，然后数丸药的手，啊嚏卓文君死了两千年，春天还是春天（你不知道你是谁，你不知道）那美丽的寡妇，年轻的寡妇（你不知道你是谁，你不知道）卓文君死了二十个世纪，春天（你不知道你是谁，你不知道）卓文君死了二十个世纪，春天卓文君死了二十个世纪，春天还是春天还是云很天鹅，女孩子们很孔雀还是云很潇洒，女孩子们很四月老教授，换一条花领带吧大二时你有没有谈过恋爱？　你不知道你是谁，你不知道卓文君　死了两千年，春天还是春天茶花女，济慈（你不知道）卓文君死了两千年，春天还是（你不知道你是谁）春天还是春天告别生命的斑马线告别海盗版的书和生命告别台北，这食蚁兽告别我的雨帽和雨衣这是春天呢，这是发呆的季节春天在大度山上喊我说风自海峡来，海峡醒了（你不知道，你不知道）牧神在大学的红砖墙外（你不知道，你不知道）不会来旁听你的古典时代牧神在女生宿舍的墙外也不修罗密欧与朱丽叶老教授，老教授，换一条领带大一时你有没有闹过恋爱？professor，yourtie，yourtie！（你不知道你是谁，你不知道）\n"},{"title":"DP—背包问题","url":"/2021/03/18/DP%E2%80%94%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","content":"1. 01背包AcWing 01背包问题 题源\n\n$N$ 件物品，背包容量为 $V$ 。每件物品只能使用一次，选/不选。\n第 $i$ 件物品的体积为 $v_i$，价值是 $w_i$。\n选择部分物品装入背包，使总体积不超过背包容量，且总价值最大。\n\n设置F[i][j]，表示前 $i$ 件物品中选取若干件物品放入剩余空间为 $j$ 的背包中所能得到的最大价值。\n\n输入样例\n4 51 22 43 44 5\n输出样例：\n8\n\n\n\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int weight[1005], volumn[1005];int dp[1005][1005]; //总价值int main()&#123;    int n, m;    /*    t: 物品个数    m: 背包容积    */    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;volumn[i], &amp;weight[i]); //输入物品体积、价值    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        for (int j = 0; j &lt;= m; j++)        &#123;            dp[i][j] = dp[i - 1][j];                                     //到达下一步时，不选当前物品            if (j &gt;= volumn[i])                                             //剩余容量大于当前物体体积                dp[i][j] = max(dp[i - 1][j - volumn[i]] + weight[i], dp[i - 1][j]); //判断不选当前物品和选了当前物品，背包总价值大小        &#125;    &#125;    printf(&quot;%d&quot;, dp[n][m]);&#125;\n\n\n一维 dp[i]，滚动数组优化\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int dp[1005]; //总价值int main()&#123;    int n, m, volumn, weight;    /*    t: 物品个数    m: 背包容积    */    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;volumn, &amp;weight);        for (int j = m; j &gt;= volumn; j--) //倒过来，从大到小        &#123;            dp[j] = max(dp[j], dp[j - volumn] + weight); //判断不选当前物品和选了当前物品，背包总价值大小        &#125;    &#125;    printf(&quot;%d&quot;, dp[m]);&#125;\n\n\n\n\n\ndp[i]表示空间&lt;= 0的最大价值，所以最后直接输出dp[m]即可，因为``dp[i]在主函数外定义，初始值均为0`。\n\n\n\n\n若题目要求恰好装满背包，初始化条件改为将dp[i]初始化为$-\\infin$，dp[0] = 0。\n\n\n2. 完全背包AcWing 完全背包问题 题源\n\n$N$ 件物品，背包容量为 $V$ 。每件物品可使用无数次。\n第 $i$ 件物品的体积为 $v_i$，价值是 $w_i$。\n选择物品装入背包，使总体积不超过背包容量，且总价值最大。\n\n在01的基础上把dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i])改为\ndp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i])即可。\n\n输入样例\n4 51 22 43 44 5\n输出样例：\n10\n\n#include &lt;bits/stdc++.h&gt;#define MAXN 10006using namespace std;int volumn[MAXN];int weight[MAXN];int dp[MAXN][MAXN];int main()&#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)    &#123;        cin &gt;&gt; volumn[i] &gt;&gt; weight[i];    &#125;    for (int i = 1; i &lt;= n; i++)     &#123;        for (int j = 0; j &lt;= m; j++)         &#123;            dp[i][j] = dp[i-1][j];            if(j &gt;= volumn[i])             &#123;                dp[i][j] = max(dp[i][j], dp[i][j - volumn[i]] + weight[i]);  // 与01背包不同，(j - 1) -&gt; j            &#125;        &#125;    &#125;    cout &lt;&lt; dp[n][m] &lt;&lt; endl;&#125;\n\n\n一维\n\n#include &lt;bits/stdc++.h&gt;#define MAXN 10006using namespace std;int volumn[MAXN];int weight[MAXN];int dp[MAXN];int main()&#123;    int n, m, volumn, weight;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)    &#123; \t\tcin &gt;&gt; volumn &gt;&gt; weight;        for (int j = volumn; j &lt;= m; j++)\t//从小到大        &#123;            dp[j] = max(dp[j], dp[j - volumn] + weight);  // 与01背包不同，(j - 1) -&gt; j        &#125;    &#125;    cout &lt;&lt; dp[m] &lt;&lt; endl;&#125;\n\n\n\n3. 多重背包AcWing 多重背包问题1 题源\n\n$N$ 件物品，背包容量为 $V$ 。\n第 $i$ 件物品的体积为 $v_i$，价值是 $w_i$，最多有$s_i$个。\n选择物品装入背包，使总体积不超过背包容量，且总价值最大。\n\n01背包的扩展，再加一层循环：k = 1, 2, 3, … s[i]表示选多少个：即\n\n\ndp[j] = max(dp[j], dp[j - v[i]] + w[i])改为\n  dp[j] = max(dp[j], dp[j - v[i] * k] + w[i] * k)即可。\n\n初级，三重循环，MAXN&lt;$10^3$\n\n输入样例\n4 51 2 32 4 13 4 34 5 2\n输出样例：\n10\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN 105int dp[MAXN]; //总价值int volumn[MAXN];int weight[MAXN];int num[MAXN];int main()&#123;    int n, m;    /*    t: 物品个数    m: 背包容积    */    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;volumn[i], &amp;weight[i], &amp;num[i]);    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        for (int j = m; j &gt;= volumn[i]; j--)\t//和01一样倒过来，从大到小        &#123;            for (int k = 1; k &lt;= num[i] &amp;&amp; j &gt;= k * volumn[i]; k++)\t\t//枚举每样物品的选择个数            &#123;                dp[j] = max(dp[j], dp[j - k * volumn[i]] + k * weight[i]);            &#125;        &#125;    &#125;    printf(&quot;%d&quot;, dp[m]);&#125;\n\n\n二进制优化\nAcWing 多重背包问题 题源\n\n复杂度  $MAXN * log(MAXV) * MAXV$\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN 1007#define MAXV 2007int dp[MAXV]; //总价值int volumn[MAXN*MAXV];int weight[MAXN*MAXV];int main()&#123;    int n, m;    int unitv, unitw, unitn;    /*    n: 物品个数    m: 背包容积    */    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int digitNum = 0;    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;unitv, &amp;unitw, &amp;unitn);        int digitMax = 1;        while (digitMax &lt;= unitn)        &#123;            digitNum++;            volumn[digitNum] = unitv * digitMax;            weight[digitNum] = unitw * digitMax;            unitn -= digitMax;            digitMax *= 2;        &#125;        if (unitn &gt; 0)        &#123;            digitNum++;            volumn[digitNum] = unitv * digitMax;            weight[digitNum] = unitw * digitMax;        &#125;    &#125;    n = digitNum;    for (int i = 1; i &lt;= n; i++)    &#123;        for (int j = m; j &gt;= volumn[i]; j--)        &#123;            dp[j] = max(dp[j], dp[j - volumn[i]] + weight[i]);        &#125;    &#125;    cout &lt;&lt; dp[m] &lt;&lt; endl;&#125;\n\nTo be continued (…&gt;-&lt;…)\n","tags":["DP"]}]